---
title: "overview of tidygenclust"
output: rmarkdown::html_vignette
        #pdf_document
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Installation

`tidygenclust` provides tools to perform clustering for population genetics within
R. It integrates with `tidypopgen` to provide a tidy interface to the results of
the analysis, and takes advantage of the python packages `fastmixture` and `clumppling`
to run the clustering analysis and to summarise the results of multiple runs, respectively.
We use `reticulate` to seamlessly integrate the python packages into R, so that you, as a user,
should not need to worry about the details of the python packages.

The first time we runt the packages, we need to install the python packages. We can do this:
```{r}
library(tidygenclust)
```
```{r eval=FALSE}
tgc_tools_install()
```







# Running clumppling

Clumppling allows to align multiple runs of a clustering algorithms within and across K. Here
we use the Capeverde example (as in the clumppling manual), stored as a zip archive:
```{r load_capeverde}
input_path <- system.file("extdata/capeverde.zip", package = "tidygenclust")
clump_res <-clumppling(input_path = input_path)
```

Once we have a clumppling object, we can use `autoplot` to make a number of
default plots. We can plot the modes for all k with:

```{r}
autoplot(clump_res, type="all_modes")
```
If we have information about the population from which individuals were sampled,
we can overlay it by providing a vector with a population label for each individual.
For the Capeverde dataset, we have such a vector stored in the package:
```{r}
head(capeverde_pops)
```

Let's get a summary:
```{r}
table(capeverde_pops)
```

We can now add it to our plots with:
```{r}
autoplot(clump_res, type="all_modes", group = capeverde_pops)
```


And subset to only the major modes with:
```{r}
autoplot(clump_res, type="major_modes", group = capeverde_pops)
```

The modes of a specific k value can be plotted with:
```{r}
autoplot(clump_res, type = "modes_within_k", k = 4, group = capeverde_pops)
```


We can also visualise the relationship among modes by plotting over a a multipartite graph,
where better alignment between the modes is indicated by the darker color
of the edges connecting their structure plots (i.e edges with a lower cost of optimal
alignment is labelled on each edge):
```{r}
autoplot(clump_res, type="modes", group = capeverde_pops)
```

`rclumppling` can also deal with very large K and gaps in the k values explored.
For example, we can use the 'chicken_gapK' data example from 'clumppling',
which uses outputs from STRUCTURE (so we need to specify the `input_format`:
```{r load_chicken}
input_path <- system.file("extdata/chicken_gapk.zip", package = "tidygenclust")
chicken_res <-clumppling(input_path = input_path, input_format = "structure")
```

We can plot the membership plots on top of the multipartite plot with:
```{r}
autoplot(chicken_res)
```


# Making custom plots with `ggplots2`

We can use `tidy()` to extrct information from a `clumppling` object. To
get all the modes for each k, we use:
```{r}
tidy(clump_res, matrix = "modes")
```

The major modes can be obtained simply with:
```{r}
tidy(clump_res, matrix = "major_modes")
```

To create custom plots, we can also extract the q matrices for modes, with their clusters aligned, by typing:
```{r}
q_modes <- tidy(clump_res, matrix = "Q_modes")
```

`q_modes` is a list of tibbles, one per mode:
```{r}
names(q_modes)
```

If we only want the major modes, we can simply use:
```{r}
q_major_modes <- tidy(clump_res, matrix = "Q_major_modes")
names(q_major_modes)
```

Let us inspect one of the tidied modes:
```{r}
q4_tidied <- q_major_modes[["K4M1"]]
head(q4_tidied)

```
We can now create a simple plot of this mode with:
```{r}
# set up the ggplot object
plt <- ggplot2::ggplot(q4_tidied,
                       ggplot2::aes(x = id,
                                    y = percentage,
                                    fill = q)) +
  # add the columns based on percentage membership to each cluster
  ggplot2::geom_col(width = 1,
                    position = ggplot2::position_stack(reverse = TRUE))+
  # set the y label
  ggplot2::labs(y = "K = 4")+
  # use a theme to match the distruct look, removing most decorations
  theme_distruct() +
  # set the colour scale to be the same as in distruct and clumppling
  scale_fill_distruct()

plt
```
We used a preset theme and colour scale, but you could use any custom option
you prefer by using standard `ggplot2` theme and scale_fill options. For example:

```{r}
plt + ggplot2::scale_fill_viridis_d(guide = "none")

```

STOP WE NEED TO THINK ABOUT THIS. THE FUNCTION IS INTERNAL IN tidypopgen, SO WE NEED TO THINK ABOUT HOW TO MAKE IT AVAILABLE TO THE USER
It is also possible to add information about the populations with
`annotate_group_info()`:
```{r eval=FALSE}
plt + annotate_group_info(group = capeverde_pops)
```
