---
title: "overview of tidygenclust"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Using `tidygenclust` for clustering in R

`tidygenclust` allows you to run `fastmixture` clustering analyses on your genetic
data directly from R.

`fastmixture` (<https://github.com/Rosemeis/fastmixture>) (Santander et
al. 2024) is a python tool for ancestry estimation using genotype
data. It uses a model-based approach with comparable accuracy to that of
of popular clustering tool ADMIXTURE, but over considerably faster time
scales making it a more scaleable option for large genetic data sets.

With the `tidygenclust` package we provide a direct R interface to the python based 
`fastmixture` using `reticulate` and integrate it with the `tidypopgen` package
for easy genetic data manipulation entirely within R. Additionally, the outputs 
from `tidygenclust` analyses can be easily visualised using the `clumpplingr` 
package which allows for easy alignment and comparison of multiple clustering 
results.

Genetic data analyses through the integrated tools `tidypopgen`, `tidygenclust`
and `clumpplingr` seamlessly joins upstream genetic data manipulation (`tidypopgen`)
with downstream clustering analyses (`tidygenclust`) and extensive visualisation 
options of the clustering results (`clumpplingr`) in an integrated pipeline
all natively within R.


# Installation

We use `reticulate` to seamlessly integrate the required python packages into R,
this means that you, as a user, should not need to worry about the details of 
the python packages or dependencies.

The first time we run `tidygenclust`, we need to install the python
packages. We can do this by simply running the following commands:
```{r}
library(tidygenclust)
```

```{r eval=FALSE}
tgc_tools_install()
```

# An example workflow

To explore the use of `tidygenclust` with `tidypopgen`, we will
investigate the genetic ancestry the anolis lizard *Anolis punctatus*
across its range in South America, using data from Prates et al 2018.

We downloaded the vcf file of the genotype data from the Prates et al
2018 GitHub repository which can be accessed
[here](%22%3Chttps://github.com/ivanprates/2018_Anolis_EcolEvol/blob/master/data/VCFtools_SNMF_punctatus_t70_s10_n46/punctatus_t70_s10_n46_filtered.recode.vcf?raw=true%3E%22)
and compressed it to a vcf.gz file.

## Read data into `gen_tibble` format

`tidygenclust` can take a path to a PLINK binary file as input, but in
this case we will read the data directly from a `tidypopgen`
`gen_tibble` object.

First, using `tidypopgen` we can read our compressed vcf file directly
into R to create our `gen_tibble`:
```{r}
library(tidypopgen)
vcf_path <-  system.file("/extdata/anolis/punctatus_t70_s10_n46_filtered.recode.vcf.gz",
                          package = "tidypopgen")
anole_gt <- gen_tibble(vcf_path, quiet = TRUE, backingfile = tempfile("anolis_"),
                       parser = "cpp")
```

By inspecting our `gen_tibble` we can see that we have a total of 46
individuals and 3249 loci, but no population information attached yet:
```{r}
anole_gt
```

We can easily attach the population metadata to our `gen_tibble` which
is stored in anther file that can be found on the Prates et al 2018
GitHub repository
[here](%22%3Chttps://github.com/ivanprates/2018_Anolis_EcolEvol/raw/master/data/plot_order_punctatus_n46.csv%3E).

We can read this file into R and attach the population information to
our `gen_tibble` after removing the prefix from the individual IDs:
```{r}
pops_path <- system.file("/extdata/anolis/plot_order_punctatus_n46.csv",
                        package = "tidypopgen")
pops <- readr::read_csv(pops_path)
anole_gt <- anole_gt %>% mutate(id = gsub('punc_',"",.data$id,))
anole_gt <- anole_gt %>% mutate(population = pops$pop[match(pops$ID,.data$id)])
```

Now we can inspect the `gen_tibble` object again to see that the
population information has been added to our genotypes:
```{r}
anole_gt
```

Finally, we group our `gen_tibble` by population to make it easier to
plot later, as the grouping information will be passed to objects created by
clustering algorithms:
```{r}
anole_gt <- anole_gt %>% group_by(population)
```


## Data preparation and PCA

To get an initial idea of our data and potentially help choose a
reasonable starting value for *k* we may want to run a principal
component analyses (PCA) to explore the data prior to running the
`fastmixture` analyses.

Before running the PCA we also need to impute any missing values that
may be present in our data.

We can quickly and easily impute and perform a PCA on our `gen_tibble`
with `tidypopgen`:
```{r}
anole_gt <- anole_gt %>% gt_impute_simple(method = "mode")

anole_pca <- anole_gt %>% gt_pca_partialSVD(k=30)

library(ggplot2)
anole_pca %>% autoplot(type = "scores") + 
  aes(color = anole_gt$population) + 
  labs(color = "Population")
```

From the PCA plot we can see there seems to be three major clusters in
the anolis.

## Running fastmixture

Now we can run `fastmixture` on our `gen_tibble` object.

As a minimum the `gt_fastmixture` command requires you to supply your
input data, in this case a `gen_tibble`, and specify a value for the
number of clusters *k*.

Based on our PCA results *k* = 3 may be a good place to start:
```{r}
anole_res <- anole_gt %>% gt_fastmixture(k = 3)
```

This will *very* quickly return a single Q matrix, for one specified
*k* value. But, most likely we want to explore multiple values for *k* and should
run multiple repeats of each *k* to assess the stability of the
clustering. The `gt_fastmixture` function allows you to specify a vector
of *k* values you wish to run and the number of repeats per *k* value.

Now we are doing multiple repeat runs it is also important that for each repeat 
we specify a different seed number to ensure consistent and robust results.

Let's now set values of *k* from 2 to 4 and run 3 repeats of each *k*
value, setting a different random seed for each repeat. We also set
the option `no_freqs` to `FALSE` to include P-matrices, containing ancestral allele
frequencies, to our output:
```{r, results='hide'}
anole_res <- anole_gt %>% gt_fastmixture(k = c(2:4), n_runs = 3, 
                                          seed = c(42, 2, 16), no_freqs = FALSE)
```

Our results are returned as a `gt_admix` object which neatly packages
the outputted Q matrices, and the corresponding *k* value for that run
in a structured list.

We can get a summary of our `gt_admix` results object to see exactly
what it contains:
```{r}
anole_res %>% summary()
```

From the summary we can see our `gt_admix` object contains Q and P matrices
for 3 repeat runs of *k* values 2, 3 and 4 as expected.

We may want to inspect a specific Q or P matrix in our `gt_admix` object and 
this can be done using the `get_q_matrix` or `get_p_matrix` functions, we simply
need to specify the *k* value and the repeat run number we are interested in.

For example we can view the Q matrix corresponding to the second run of
*k* = 4 like so:
```{r}
anole_res %>% get_q_matrix(k = 4, run = 2) %>% head()
```

Or the P matrix of the first run of *k* = 3:
```{r}
anole_res %>% get_p_matrix(k = 3, run = 1) %>% head()
```

## Visualising the results

For a quick visualisation of a single Q matrix we can use the autoplot function
in `tidypopgen`:
```{r}
anole_res %>% autoplot(type="barplot", k = 3, run = 1)
```

It is possible to rearrange individual withing groups according to their ancestral
components. This makes for a visually appealing plots that focuses on the main
ancestral component within each plot, but makes multiple plots not comparable
(as individuals will not be in the same order across plots):

```{r}
anole_res %>% autoplot(type="barplot", k = 3, run = 1, reorder_within_groups = TRUE)
```
Note that the colours assigned to each component are arbitrary and may (and in this case did)
change if we reorder individuals. If you want complete control of your plot, you
can create your own customised plot with `ggplot2`; we can use `tidy()` to easily extract 
the required information from a `gt_admix` object to use for the plot: 
```{r}
anole_q_tbl <- anole_res %>% get_q_matrix(k = 3, run = 1) %>% tidy(data = anole_gt)
anole_q_tbl
```

## Moving to `clumpplingr`

Whilst this gives us a useful, quick visual to check one particular Q matrix,
ideally we want to be able to compare the different *k* values we tried in our 
clustering analyses and to assess the stability of the multiple repeat runs. 
For proper comparative visualisation and assessment of the different *k* values
and repeats we can use the `gt_clummpling` function which aligns multiple clustering
results within and between different values of *k* and allows for easy
visualisation in multipartite plots.

Once we use `gt_clumppling`, the resulting plots will only show individuals in
the order in which they were found in the `gt_admix` object. This means that,
if they were not ordered into groups, we will not be able to annotate groups. One
solution would be to arrange our original gen_tibble by group before starting the
analsyis, but we can also use `gt_admix_reorder_q` to reorder the individuals in the
groups.

```{r}
anole_gt_admix <- anole_res %>% gt_admix_reorder_q()
```

Let's now run the clumppling analysis on our `gt_admix` object:
```{r}
anole_clump <- anole_gt_admix %>% gt_clumppling()
```

And plot the results:
```{r}
anole_clump %>% autoplot(type = "all_modes", group = anole_gt_admix$group)
```

We can see that there is only one mode for each K. For more comple examples
where multiple modes are found in runs for the same K, see the vignette focussing
on `gt_clumppling`.

