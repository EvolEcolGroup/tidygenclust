---
title: "overview of tidygenclust"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Using `tidygenclust` for clustering in R

`tidygenclust` allows you to run `fastmixture` clustering analyses on your genetic
data directly from R.

`fastmixture` (<https://github.com/Rosemeis/fastmixture>) (Santander et
al. 2024) is a python tool for ancestry estimation using genotype
data. It uses a model-based approach with comparable accuracy to that of
of popular clustering tool ADMIXTURE, but over considerably faster time
scales making it a more scaleable option for large genetic data sets.

With the `tidygenclust` package we provide a direct R interface to the python based 
`fastmixture` using `reticulate` and integrate it with the `tidypopgen` package
for easy genetic data manipulation entirely within R. Additionally, the outputs 
from `tidygenclust` analyses can be easily visualised using the `clumpplingr` 
package which allows for easy alignment and comparison of multiple clustering 
results.

Genetic data analyses through the integrated tools `tidypopgen`, `tidygenclust`
and `clumpplingr` seamlessly joins upstream genetic data manipulation (`tidypopgen`)
with downstream clustering analyses (`tidygenclust`) and extensive visualisation 
options of the clustering results (`clumpplingr`) in an integrated pipeline
all natively within R.


# Installation

We use `reticulate` to seamlessly integrate the required python packages into R,
this means that you, as a user, should not need to worry about the details of 
the python packages or dependencies.

The first time we run `tidygenclust`, we need to install the python
packages. We can do this by simply running the following commands:
```{r}
library(tidygenclust)
```

```{r eval=FALSE}
tgc_tools_install()
```

# An example workflow

To explore the use of `tidygenclust` with `tidypopgen`, we will
investigate the genetic ancestry the anolis lizard *Anolis punctatus*
across its range in South America, using data from Prates et al 2018.

We downloaded the vcf file of the genotype data from the Prates et al
2018 GitHub repository which can be accessed
[here](%22%3Chttps://github.com/ivanprates/2018_Anolis_EcolEvol/blob/master/data/VCFtools_SNMF_punctatus_t70_s10_n46/punctatus_t70_s10_n46_filtered.recode.vcf?raw=true%3E%22)
and compressed it to a vcf.gz file.

## Read data into `gen_tibble` format

`tidygenclust` can take a path to a PLINK binary file as input, but in
this case we will read the data directly from a `tidypopgen`
`gen_tibble` object.

First, using `tidypopgen` we can read our compressed vcf file directly
into R to create our `gen_tibble`:
```{r}
library(tidypopgen)
vcf_path <-  system.file("/extdata/anolis/punctatus_t70_s10_n46_filtered.recode.vcf.gz",
                          package = "tidypopgen")
anole_gt <- gen_tibble(vcf_path, quiet = TRUE, backingfile = tempfile("anolis_"),
                       parser = "cpp")
```

By inspecting our `gen_tibble` we can see that we have a total of 46
individuals and 3249 loci, but no population information attached yet:
```{r}
anole_gt
```

We can easily attach the population metadata to our `gen_tibble` which
is stored in anther file that can be found on the Prates et al 2018
GitHub repository
[here](%22%3Chttps://github.com/ivanprates/2018_Anolis_EcolEvol/raw/master/data/plot_order_punctatus_n46.csv%3E).

We can read this file into R and attach the population information to
our `gen_tibble` after removing the prefix from the individual IDs:
```{r}
pops_path <- system.file("/extdata/anolis/plot_order_punctatus_n46.csv",
                        package = "tidypopgen")
pops <- readr::read_csv(pops_path)
anole_gt <- anole_gt %>% mutate(id = gsub('punc_',"",.data$id,))
anole_gt <- anole_gt %>% mutate(population = pops$pop[match(pops$ID,.data$id)])
```

Now we can inspect the `gen_tibble` object again to see that the
population information has been added to our genotypes:
```{r}
anole_gt
```

## Data preparation and PCA

To get an initial idea of our data and potentially help choose a
reasonable starting value for *k* we may want to run a principal
component analyses (PCA) to explore the data prior to running the
`fastmixture` analyses.

Before running the PCA we also need to impute any missing values that
may be present in our data.

We can quickly and easily impute and perform a PCA on our `gen_tibble`
with `tidypopgen`:
```{r}
anole_gt <- anole_gt %>% gt_impute_simple(method = "mode")

anole_pca <- anole_gt %>% gt_pca_partialSVD(k=30)

library(ggplot2)
anole_pca %>% autoplot(type = "scores") + 
  aes(color = anole_gt$population) + 
  labs(color = "Population")
```

From the PCA plot we can see there seems to be three major clusters in
the anolis.

## Running fastmixture

Now we can run `fastmixture` on our `gen_tibble` object.

As a minimum the `gt_fastmixture` command requires you to supply your
input data, in this case a `gen_tibble`, and specify a value for the
number of clusters *k*.

Based on our PCA results *k* = 3 may be a good place to start:
```{r}
anole_res <- anole_gt %>% gt_fastmixture(k = 3)
```

This will *very* quickly return a single Q matrix, for one specified
*k* value. But, most likely we want to explore multiple values for *k* and should
run multiple repeats of each *k* to assess the stability of the
clustering. The `gt_fastmixture` function allows you to specify a vector
of *k* values you wish to run and the number of repeats per *k* value.

Now we are doing multiple repeat runs it is also important that for each repeat 
we specify a different seed number to ensure consistent and robust results.

Let's now set values of *k* from 2 to 4 and run 3 repeats of each *k*
value, setting a different random seed for each repeat:
```{r, results='hide'}
anole_res <- anole_gt %>% gt_fastmixture(k = c(2:4), n_runs = 3, 
                                          seed = c(42, 2, 16))
```

Our results are returned as a `gt_admix` object which neatly packages
the outputted Q matrices, and the corresponding *k* value for that run
in a structured list.

We can get a summary of our `gt_admix` results object to see exactly
what it contains:
```{r}
anole_res %>% summary()
```

From the summary we can see our `gt_admix` object contains Q matrices
for 3 repeat runs of *k* values 2, 3 and 4 as expected.

If we also want to return P-matrices, containing ancestral allele
frequencies, as part of our output we can set option `no_freqs` to
`FALSE`:
```{r, results='hide'}
anole_res <- anole_gt %>% gt_fastmixture(, k = c(2:4), n_runs = 3, 
                                          seed = c(42, 2, 16), no_freqs = FALSE)
```

We can see from the summary that our `gt_admix` output now contains
both Q and P matrices for 3 repeat runs of each *k* value 2, 3 and 4:
```{r}
anole_res %>% summary()
```

We may want to inspect a specific Q or P matrix in our `gt_admix` object and 
this can be done using the `get_q_matrix` or `get_p_matrix` functions, we simply
need to specify the *k* value and the repeat run number we are interested in.

For example we can view the Q matrix corresponding to the second run of
*k* = 4 like so:
```{r}
anole_res %>% get_q_matrix(k = 4, run = 2) %>% head()
```

Or the P matrix of the first run of *k* = 3:
```{r}
anole_res %>% get_p_matrix(k = 3, run = 1) %>% head()
```

## Visualising the results

For a quick visualisation of a single Q matrix from our results we can
again pull out a specific Q matrix of interest using the `get_q_matrix`
function and pass it directly to autoplot in `tidypopgen`:
```{r}
anole_res %>% get_q_matrix(k = 3, run = 1) %>% autoplot()
```

If we want to add population annotations we can set the `annotate_group` option 
to `TRUE` and pass our `gen_tibble` to the `data` argument of `autoplot`:
```{r}
anole_res %>% get_q_matrix(k = 3, run = 1) %>% 
  autoplot(annotate_group = TRUE, data = anole_gt)
```

If we want to create customised plots, we can use `tidy()` to easily extract 
the required information from a `gt_admix` object to use with `ggplot2`: 
```{r}
anole_res %>% get_q_matrix(k = 3, run = 1) %>% tidy(data = anole_gt)
```

## Moving to `clumpplingr`

Whilst this gives us a useful, quick visual to check one particular Q matrix,
ideally we want to be able to compare the different *k* values we tried in our 
clustering analyses and to assess the stability of the multiple repeat runs. 
For proper comparative visualisation and assessment of the different *k* values
and repeats we can use the `clummplingr` package which aligns multiple clustering
results within and between different values of *k* and allows for easy
visualisation in multipartite plots.

To use `clumpplingr` on our `gt_admix` results we can simply save our
`gt_admix` object and reopen it in a new R session with the
`clummplingr` package:
```{r, eval = FALSE}
anole_res %>% saveRDS("anole_gt_admix.rds")
```

Further details on next steps in `clumpplingr` can be found in the
`clumpplingr` [GitHub
repository](https://github.com/EvolEcolGroup/clumpplingr) and vignette.


## Additional options

Additional to the main options outlined in this example workflow the
`gt_fastmixture` function allows you to specify all the extra options
which are available when using the standard `fastmixture` software and
as default these to the same values as `fastmixure`. This includes:

-   `threads`: the number of threads to use (1)
-   `iter`: the maximum number of iterations (1000)
-   `tole`: the tolerance in log-likelihood units between iterations
    (0.5)
-   `batches`: the number of maximum mini-batches (32)
-   `supervised`: the name fo the file with the supervised labels
    (`NULL`)
-   `check`: the number of iterations to check for convergence (5)
-   `power`: number of power iterations in randomised SVD (11)
-   `chunk`: the number of SPs in chunk operations (8192)
-   `als_iter`: the maximum number of iterations in the ALS algorithm
    (1000) 
-   `als_tole`: the tolerance for the RMSE of P between iterations
    (1e-4)
-   `random_init`: random initialisation of parameters (`TRUE`)
-   `safety`: add extra safety steps in unstable optimizations (`TRUE`)
